### 스텝 15
- DB : Mysql 8.4
- 주요 성능향상이 야기되는 쿼리를 산정 후, 인덱스 사용 과 사용하지 않는것을 분석함으로 효율적인 데이터 판단.
- 주문데이터 1만건, 사용자데이터 2만건, 상품데이터 2만건, 쿠폰데이터 1만건씩 생성 인입.

1. Order 엔티티에 대한 인덱싱 성능 검증
```angular2html
OrderStatus 에 대한 인덱스 검증 결과 

type:
적용 전: ALL 적용 후: ref
테이블 전체 스캔(ALL)에서 인덱스를 사용한 참조(ref)로 변경되었음을 의미합니다.

possible_keys와 key:
적용 전: null 적용 후: idx_order_status
인덱스 적용 후 사용 가능한 키와 실제 사용된 키가 idx_order_status로 변경되었습니다.

key_len:
적용 전: null적용 후: 1023
인덱스 키의 길이가 지정되었습니다.
ref:
적용 전: null 적용 후: const
인덱스를 사용하여 상수 값과 비교하고 있음을 나타냅니다.

rows:
적용 전: 9492 적용 후: 2357
검사해야 할 예상 행의 수가 크게 감소했습니다.

filtered:
적용 전: 10.0 적용 후: 100.0
필터링된 행의 비율이 증가했습니다.

Extra:
적용 전: Using where 적용 후: null
WHERE 조건을 사용한 추가 필터링이 필요 없어졌습니다.
```
2. User 엔티티에 대한 인덱싱 성능 검증
```angular2html
UserName 에 대한 인덱스 검증 결과
type:
적용 전: ALL 적용 후: ref
테이블 전체 스캔(ALL)에서 인덱스를 사용한 참조(ref)로 변경되었음을 의미합니다.

possible_keys와 key:
적용 전: null 적용 후: idx_username
인덱스 적용 후 사용 가능한 키와 실제 사용된 키가 idx_username으로 변경되었습니다.

key_len:
적용 전: null 적용 후: 1023
인덱스 키의 길이가 지정되었습니다.

ref:
적용 전: null 적용 후: const
인덱스를 사용하여 상수 값과 비교하고 있음을 나타냅니다.

rows:
적용 전: 19878 적용 후: 1
검사해야 할 예상 행의 수가 크게 감소했습니다.

filtered:
적용 전: 10.0 적용 후: 100.0
필터링된 행의 비율이 증가했습니다.

Extra:
적용 전: Using where 적용 후: null
WHERE 조건을 사용한 추가 필터링이 필요 없어졌습니다.
```
3. Product 엔티티에 대한 인덱싱 성능 검증
```angular2html
Product의 name 에 대한 인덱스 검증 결과

1. type:
- 적용 전: ALL 적용 후: ref
인덱스 적용 후, 테이블 전체 스캔(ALL)에서 인덱스를 사용한 참조(ref)로 변경되었습니다. 

2. possible_keys와 key:
- 적용 전: null 적용 후: idx_product_name
인덱스 적용 후, 사용 가능한 키와 실제 사용된 키가 idx_product_name으로 변경되었습니다.

3. key_len:
- 적용 전: null 적용 후: 1023
인덱스 키의 길이가 지정되었습니다. 이는 VARCHAR 필드의 최대 길이를 나타냅니다.

4. ref:
- 적용 전: null 적용 후: const
인덱스를 사용하여 상수 값과 비교하고 있음을 나타냅니다.

5. rows:
- 적용 전: 19418 적용 후: 1
검사해야 할 예상 행의 수가 크게 감소했습니다. 

6. filtered:
- 적용 전: 10.0 적용 후: 100.0
필터링된 행의 비율이 증가했습니다.

Extra:
- 적용 전: Using where 적용 후: null
WHERE 조건을 사용한 추가 필터링이 필요 없어졌습니다.

```

```angular2html
설계 문서 작성:
a. 아키텍처 개요:
현재 Interface, Application, Domain, Infra 의 4계층 구조이며,
컨트롤러에서 요청받은 행위에대해서 Command는 변경을 요청하고, Query는 조회를 요청합니다.
컨트롤러에서 받은 요청에 대해서 동시성이 발생하는것이 예상되는 부분에 대해서 락을 획득한뒤에 트랜잭션이 시작하는 로직이 적용되어있습니다.
주문서비스는 사용자 및 상품에의해서 조합되므로 퍼사드 계층에 존재하고, 엔티티에대한 변경이나 조회가 일어나는 부분은 도메인에 존재합니다.
최근에 도메인에서 JPA기술을 알아야할 필요성이 없어 보여 도메인에서 리포지터리에서 어떤 정보를 불러올것인지 명세하고, 
구현체와 JPA 인터페이스는 인프라 계층으로 이관했습니다.

b. 서비스 분리 계획:
현재 주문 서비스 자체는 상품서비스와 사용자 서비스에 의해서 조합되고있습니다.
주문서비스의 경우 트랜잭션이 주문 결제시에 주문확인 -> 재고 차감 -> 포인트 차감 -> 결제완료 -> 외부플랫폼 전송이므로
외부 서비스가 추가될수록 트랜잭션의 점유시간이 길어지고, 부분실패에 대한 보상 트랜잭션이 어려워집니다.
이에 따라서 주문서비스에서 여러 서비스를 조합 하는 경우에 대해서 서비스를 분리하고, 
이벤트 기반으로 처리하는 방식을 고려하고 있습니다.

주요 이벤트 목록
1. 주문 결제 
2. 주문 취소

1. 상품 재고 증가
2. 상품 재고 감소

1. 사용자 포인트 증가
2. 사용자 포인트 감소 

이벤트 발행 및 구독 흐름

f. 분산 트랜잭션 처리:
이벤트 기반 비동기 트랜잭션
g. 확장성 및 성능:
부하 분산 전략
캐싱 전략
```

