# 대용량 트래픽 챕터 대단원의 끝.
## 이벤트 기반 아키텍처의 이해와 카프카의 적용기
```angular2html
저번주, 이벤트 기반 아키텍처를 준비하며, 기존 서비스와 이벤트 기반으로 전환하면서 발생했던 체크포인트들을 중점으로
정리했습니다.
```
### 기존 서비스 개발기
```angular2html
기존 이커머스 서비스는 모놀리스 아키텍처로 구성되어 있었습니다.

이커머스 프로젝트는 다음과 같이 발전했었습니다.

1주차 서비스 시나리오를 선택하면서, 시나리오 요구사항 분석을 하면서 작업계획을 세웠습니다.
2주차 API 설계를 하면서 API 명세를 작성하고 그에따라 비즈니스 요구사항을 구현했었습니다.
-> 이때 시퀀스 다이어그램 , 플로우차트, 유스케이스에 대한 이해를 마쳤습니다.
3주차 인바운드 및 아웃바운드에 대해서 필터 및 인터셉터를 고려하며, 부가로직에 대해서 고려했습니다.
-----------------------------------------
4주차 서비스에 발생할수있는 도메인의 변화를 고려하며, 락과 트랜잭션을 통해 처리를 개선했습니다.
5주차 캐싱을 통해 조회 I/O 에대한 성능개선을 하며, 캐시의 유효성을 검증했습니다.
6주차 서비스의 성능을 개선하기위해 Mysql의 Explain 기능을 통해 인덱스 유효 여부를 검증했습니다.
```
### 기존 서비스 특징 및 회고
```angular2html
패키지 구조는 전반적으로 신경을 잘 쓰지않았었습니다. 단지 도메인은 지켜져야할 최후의 보루라고 생각했었습니다.

하지만 테스트를 함에있어서 JPArepository를 직접적으로 의존하면서 기술 명세에 대한 의존성이 서비스에 노출되는 문제가 있었고,
서비스에서 필요한 기능에 대한 명세를 가짐으로서 의존성을 분리할수있었고, 이게 나중에 DIP 원칙이었다는 사실을 알게되었습니다.

또 항해플러스를 하면서 가볍게 봤었던  유비쿼터스 랭귀지에 대해서 고민하지 않은 상태로 커맨드패턴을 사용해 개발을 진행했었습니다.
4L에 대해서도 정형화되어있다 판단해 어느정도 반감을 가지고있었고, 직접 쪼개고 붙이면서 알아가기로 결정했습니다.

메서드에 락을 붙이고 트랜잭션을 적용함으로서 도메인의 변화에 대해서 동시성을 제어할수있었지만, 다른 메서드에 비해 이질감이 느껴졌었습니다.
한 클래스에 이질적인 메서드가 많을수록 클래스의 책임이 커지고, 전혀 객체지향적인 코드가 아니라는 느낌이 들었습니다.

그러고 다시 4L 을 보고나서 외부 의존성이나 다른 도메인들의 조합이 일어나는것들을 어플리케이션 계층으로 올렸습니다.
유스케이스를 사용해서 조합했던것들이 결국에는 서비스 코드들의 결합도를 낮추기위해서였던것들과, 과한 어플리케이션의 비대를 방지하는데 도움이 되었습니다.

어플리케이션 계층의 특징상 다른 도메인들과의 조합은 기존 도메인의 조회와 변경의 조합이라는 점을 알게되어, 
기존 서비스를 전부 도메인별로 조회와 변경부분을 나눠보았습니다. 
진행하며 오히려 도메인의 변경에 대해서 오히려 조회와 변경이 분리된다고해서 도메인의 행위가 딱, 맞아떨어지지않는다는 점이 특이했습니다.

또 멘토링을 하면서 배웠던것이긴 했지만, 4L로 올리고나니 도메인객체를 바로 반환하는것이 특이하게 느껴져 DTO 객체, Info 객체를 만들었습니다.
이로인해 도메인의 변경에 대해서는 도메인 객체를 변경하고, 조회에 대해서는 DTO 객체를 변경하면서 도메인의 변경에 대한 영향을 최소화할수있었습니다.

물론 JPA 엔티티가 도메인이라고 생각하지만, JPA 엔티티는 컬렉션 객체에 있어서 제약을 많이 느껴,
JPA 엔티티를 단지 엔티티와 읽기 모델, 그리고 쓰기모델로 나뉘어서 사용하면서, JPA 엔티티의 제약을 최소화할수있었습니다.

하지만 실질적으로 읽기모델은 거의 사용되지 않으면서, 읽기모델은 단순 DTO와 차이가 없다는 것을 알게되었고, 
이로인해 어떻게보면 도메인 객체 자체가 데이터베이스 엔티티 와 매핑된 JPA 엔티티에대한 쓰기모델이라고 느꼈습니다.

이로인해 크게 보면, 어플리케이션은 도메인과 도메인을 변경하는 작업 두가지로 나눠지고 변경하는 작업은 도메인을 확인하기전까지는,
독립적이라고 생각하게되었습니다. 

발제 내용상으로 트랜잭션이 외부영향을 많이 안받을수록, 또 변경이 일어나는 부분을 최소화할수록 좋다는 격언을 들어 트랜잭션의
독립성을 어떻게 보장해줘야할까 생각이들어 이벤트를 고민하기 시작했습니다.
```
### 이벤트 기반 아키텍처
```angular2html
이벤트기반 아키텍처의 주요 개념

이벤트: 시스템내에서 주요한 변화나 사건을 의미합니다.
이벤트 생산자, 이벤트 소비자: 이벤트를 생성하고 소비하는 시스템입니다.
이벤트 브로커: 이벤트를 중개하는 시스템입니다.
비동기 통신: 서비스간 직접적인 의존성을 낮춥니다.


이벤트 기반 아키텍처는 마이크로서비스와 같은가? 
- 이벤트 기반 아키텍처와 밀접한 관련이 있지만, 마이크로서비스는 꼭 이벤트기반 아키텍처를 따르지 않아도 됩니다.
- 이른바 상호작용의 방법의 차이죠. 마이크로서비스는 서비스간의 상호작용을 HTTP, REST API를 통해 직접적으로 통신합니다.
- 이벤트 기반 아키텍처는 서비스간의 상호작용을 이벤트를 통해 간접적으로 통신합니다.

도메인 주도 설계의 도메인 이벤트: 비즈니스 도메인내에서의 주요한 변화, 단일 바운디드 컨텍스트의 변화입니다.
이벤트 기반 아키텍처의 이벤트: 시스템 전반의 통신과 상호작용을 위한 이벤트입니다.
바운디드 컨텍스트 : 시스템간의 논리적 경계를 가진 컨텍스트입니다.

도메인과 시스템의 관계는 어떻게 되는가?
- 시스템: 상호작용하는 요소들의 집합입니다.
- 도메인: 어플리케이션이 대상으로 하는 주제영역입니다.
- 도메인과 시스템의 관계: 도메인은 비즈니스 관점에서 접근하고, 시스템은 기술적인 관점에서 접근합니다.
```
### 이벤트 기반 아키텍처로의 전환하는 과정
```angular2html
1. 기존 도메인에서의 에서의 주요한 상태변화들을 식별해야합니다.
2. 상태변화를 담당하는 비즈니스 로직을 직접적인 실행에서 이벤트를 발행하고, 이벤트를 수신하는 방식으로 변경해야합니다.
3. 이벤트를 발행하고 수신하는 방식으로 변경할때, 서비스 특성에 맞는 메시지브로커를 선택해야합니다.

1,2,3 을 진행하면서 어플리케이션 계층에서 상당히 고민해볼법한 문제가 하나 있습니다.
어플리케이션에서는 특정 도메인의 조회를 통해 변경을 이벤트를 발행하는데, 조회도 이벤트로 발행해야할까요?

조회를 이벤트로 발행했을때의 
장점: 모든 요청을 이벤트로 처리할수있어, 도메인의 변경에 대한 의존성을 최소화할수있습니다.
단점: 비동기 처리로인해 데이터의 일관성을 유지하기가어려워서, 최종일관성(eventual consistency)에 문제가 발생할 수있습니다.

그러면 최종일관성은 무엇일까요?
- 이벤트의 순서 또는 시간에 따라 데이터의 일관성이 유지되지 않지만 최종적으로는 일관성이 유지되는것을 말합니다.
- 이벤트 기반 아키텍처에서는 최종일관성을 유지하기 위해 이벤트의 순서를 보장하는 방법을 고민해야합니다.

이벤트의 순서를 보장하는 방법은 무엇일까요?
1. 타임스탬프를 활용하기
2. 이벤트 버전을 활용하기
3. 상태머신을 활용하기
4. 이벤트소싱 패턴을 활용하기

이정도면 이벤트 기반 아키텍처로의 전환을 위한 기본적인 고민들을 해볼수있을것같습니다.

추가적으로 고려해야할것들은 무엇이있을까요?
1. 이벤트 스토리지: 이벤트를 저장함으로서 시점을 기록하고, 이벤트의 스냅샷을 생성할수 있습니다.
2. 이벤트 라우팅 및 필터링: 후술할 메시지 브로커와 같이 기술하겠습니다.
3. 오류 처리및 재시도 메커니즘

3-1. 데드레터큐
- 데드레터큐는 메시지 브로커에 전달되지 못한 메시지를 보관하는 큐입니다. 재시도 정책과 함께 사용되어 처리되지 않은 메시지를 저장할수있습니다.
3-2. 재시도 메커니즘
- 재시도 메커니즘은 메시지를 처리하는 과정에서 오류가 발생했을때, 메시지를 다시 처리할수있는 방법을 제공합니다.
3-2-1. 지수 백오프
- 지수 백오프는 재시도 횟수를 지수적으로 증가시키는 방법입니다. 재시도 횟수가 증가할수록 재시도 간격이 증가합니다.
3-2-2. 랜덤 지터
- 랜덤 지터는 재시도 간격을 랜덤하게 설정하는 방법입니다. 재시도 간격을 랜덤하게 설정함으로서, 재시도 메시지의 충돌을 방지할수있습니다.

```
### 트랜잭셔널 아웃박스 패턴
```angular2html
더도말고 덜도말고, 이벤트 기반 아키텍처에서는 이벤트 발행의 원자성을 보장하는것이 중요합니다.
트랜잭셔널 아웃박스 패턴은 이벤트 발행을 비동기로 트랜잭션과 분리하는 패턴입니다.
메시지브로커의 일시적인 장애를 판단해서 이벤트 발행을 실행해서 메시지의 멱등성을 보장합니다.

기본적인 트랜잭셔널 아웃박스 패턴과 일반적인 이벤트 발행의 순서의 차이는 다음과 같습니다.
1. 일반적인 패턴
- 이벤트 발행을 요청합니다.
- 이벤트 발행이 성공하면, 트랜잭션을 커밋합니다.
2. 트랜잭셔널 아웃박스 패턴
- 이벤트 발행을 아웃박스에 저장합니다.
- 아웃박스에서는 비동기로 이벤트 발행을 실행합니다.
- 이벤트 발행이 실패하면, 재시도 로직을 통해 이벤트 발행을 재시도합니다.
- 성공한 이벤트 발행은 아웃박스에서 삭제합니다.

트랜잭셔널 아웃박스 패턴을 적용할때 고려해야할것은 무엇일까요?
1. 이벤트 발행의 원자성을 보장해야합니다.
- 재시도 로직이 필요합니다.
2. 아웃박스 테이블은 장기보관을 목적으로 하지않습니다.
- 메시지브로커를 위한 단기적인 메시지 큐의 역할을합니다.
```
### 이벤트 소싱 패턴
```angular2html
반대로 이벤트 소싱 패턴은 이벤트를 저장함으로서 시점을 기록하고, 이벤트의 스냅샷을 생성할수있습니다.
이벤트를 순서를 통해 기록해서 발행한다는점에서 트랜잭셔널 아웃박스와의 모습은 굉장히 비슷합니다.

하지만 이벤트 소싱은 이벤트 전부를 이벤트 스토어에 기록함으로서 시점을 기록하고, 이벤트의 스냅샷을 생성하는게 주 목적입니다.
그러한 복원능력을 주요 쟁점으로 삼는걸 '재생성(Replay)' 이라고 부르기에, 재생성에 대한 간단한 이해도 필요합니다.

이벤트 소싱의 과정
1. 이벤트 발행을 요청합니다.
2. 이벤트 발행 요청을 이벤트 스토어에 저장합니다.
3. 이벤트 스토어에서 이벤트를 읽어와서 이벤트를 발행합니다.
4. 다만 완료된 이벤트 스토어는 삭제하지않고, 재생성을 위해 보관합니다.

재생성이란?
-  저장된 이벤트를 시간 순서대로 실행하여 특정 시점의 상태를 온전하게 복원하는것을 의미합니다.

그렇기에 이벤트 소싱 패턴은 트랜잭셔널 아웃박스 패턴과 다르게, 이벤트를 전반적으로 재생성이 필요할 경우에 구현됩니다.
재생성이 필요한 경우: 금융감사시스템, 버전관리 시스템
재생성이 필요하지 않은 경우: 실시간 스트리밍 서비스
```
### 사가 와 2PC
```angular2html
사가(Saga)와 2PC(Two-Phase Commit)은 분산 트랜잭션 처리의 일관성을 유지하기 위한 패턴입니다.

사가와 2PC의 특징, 그리고 과정
1. 사가
- 사가는 분산 트랜잭션을 여러개의 로컬 트랜잭션으로 분리합니다.
- 사가는 각 로컬 트랜잭션을 순차적으로 실행하며, 각 로컬 트랜잭션의 결과를 이벤트로 발행합니다.

사가 - 코레오그래피
1. 트랜잭션 시작을 위한 이벤트 발행
2. 서비스가 로컬 트랜잭션을 실행하고 결과 이벤트를 발행
3. 다음 서비스가 이벤트를 수신하고 로컬 트랜잭션을 실행하고 결과 이벤트를 발행
4. 마지막 서비스가 이벤트를 수신하고 로컬 트랜잭션을 실행하고 트랜잭션 마무리
* 코레오그래피의 경우 각 서비스 내부에서 상태머신을 사용합니다.

사가 - 오케스트레이션
1. 사가 오케스트레이터가 트랜잭션 시작
2. 사가 오케스트레이터가 각 서비스에 로컬 트랜잭션을 실행하라는 명령
3. 각 서비스가 로컬 트랜잭션을 실행하고 결과 이벤트를 오케스트레이터에 전달
4. 사가 오케스트레이터가 모든 서비스의 결과를 확인하고 트랜잭션 마무리
* 오케스트레이션의 경우 사가 오케스트레이터에서 상태머신을 사용합니다. 

2. 2PC
- 2PC는 분산 트랜잭션을 전체적으로 관리합니다.
- 2PC는 모든 로컬 트랜잭션을 준비상태로 변경하고, 모든 로컬 트랜잭션의 준비상태를 확인한 후, 커밋 또는 롤백을 결정합니다.

2PC의 과정
1. 코디네이터가 트랜잭션을 시작합니다.
2. 코디네이커가 모든 참여자에게 트랜잭션을 준비하라는 명령을 전달합니다.
3. 모든 참여자가 준비를 완료하면, 코디네이터가 커밋 또는 롤백을 결정합니다.

사가와 2PC의 차이점
사가는 각 로컬 트랜잭션이 커밋해서 단계별로 진행되는 것에 반해, 2PC는 한 참여자라도 아니오라고 응답하면 블로킹됩니다.
그렇기에 사가에 비해 2PC는 강한 일관성을 띄지만 참여자 수가 늘어날수록 가용성이 떨어집니다.

결국 방식은 다르지만 이 두개의 패턴은 모두 최종일관성을 위한 전략들입니다.
```
### 상태머신과 전이
```angular2html
상태 머신은 시스템의 상태와 상태 간 전이를 모델링하는 추상적인 기계입니다.

주요 구성 요소:
1. 상태(State): 시스템이 특정 시점에 있을 수 있는 조건이나 상황
2. 전이(Transition): 한 상태에서 다른 상태로의 변화
3. 이벤트(Event): 전이를 트리거하는 외부 자극이나 조건
4. 액션(Action): 전이 중에 실행되는 동작

상태 머신의 특징:
- 현재 상태를 명확히 정의합니다.
- 이벤트에 따라 상태 간 전이 규칙을 정의합니다.
- 복잡한 시스템 동작을 단순화하여 모델링할 수 있습니다.

전이와 전파
전이: 한 상태에서 다른 상태로 변화하는것을 의미합니다.
전파: 상태가 한 지점에서 다른 지점으로 이동되는것을 의미합니다.

결국 상태머신이던 도메인의 변화로 일어난 이벤트던 시스템 내부의 상태가 전이하고, 
다른 시스템으로 전파되는것을 이해하는것이 중요하다고 생각합니다.
```
## 메시지 브로커
```angular2html
메시지 브로커는 애플리케이션, 시스템 및 서비스 간에 메시지를 중개합니다.
주요 기능:
1. 메시지 라우팅: 발신자로부터 수신자로 메시지를 전달합니다.
2. 메시지 변환: 필요에 따라 메시지 형식을 변환합니다.
3. 메시지 저장: 수신자가 처리할 준비가 될 때까지 메시지를 저장합니다.
4. 신뢰성 있는 전달: 메시지 손실을 방지하고 최소 한 번 전달을 보장합니다.

이벤트 기반 아키텍처에서의 역할:
- 서비스 간 느슨한 결합 제공
- 비동기 통신 지원
- 시스템 확장성 향상
- 부하 분산 및 피크 처리

음... 카프카 내용을 이 다음에 정리하려고 했는데 너무 방대하네요. 다른 게시물을 작성해봐야할것같습니다.
```

